pipeline {
  agent any
  options {
    timestamps()
    // Manage Jenkins > Configure System > GitLab 에서 만든 연결 이름
    gitLabConnection('o-o')
  }

  environment {
    AWS_REGION      = 'ap-northeast-2'
    CLUSTER         = 'o-o-cluster'
    ECR_REPO        = 'o-o-backend'
    NAMESPACE       = 'prod'
    PARALLEL_BUILD  = 'true'

    // 전체 파이프라인 상태 라벨
    GITLAB_STAGE    = 'backend-deploy'
  }

  stages {

    stage('Checkout') {
      steps {
        gitlabBuilds(builds: ['Checkout']) {
          checkout scm
        }
      }
    }

    stage('ECR Login & Ensure Repo') {
      steps {
        gitlabBuilds(builds: ['ECR Login & Ensure Repo']) {
          withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                            usernameVariable: 'AWS_ACCESS_KEY_ID',
                                            passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
            sh '''
              set -e
              export AWS_DEFAULT_REGION=${AWS_REGION}
              export AWS_EC2_METADATA_DISABLED=true

              ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
              echo "[whoami] $ACCOUNT_ID"

              aws ecr describe-repositories --repository-names ${ECR_REPO} >/dev/null 2>&1 || \
                aws ecr create-repository --repository-name ${ECR_REPO} --image-scanning-configuration scanOnPush=true

              aws ecr get-login-password --region ${AWS_REGION} \
                | docker login --username AWS --password-stdin ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

              echo $ACCOUNT_ID > .b_account_id
            '''
          }
        }
      }
    }

    stage('Detect Services to Build') {
      steps {
        gitlabBuilds(builds: ['Detect Services']) {
          sh '''
            set -e
            SERVICES=$(ls -d backend/*-service 2>/dev/null | xargs -n1 basename || true)
            [ -z "$SERVICES" ] && { echo "No backend/*-service found"; exit 1; }

            CHANGED=""
            if git rev-parse --verify -q "$GIT_PREVIOUS_SUCCESSFUL_COMMIT" >/dev/null 2>&1; then
              DIFF_FILES=$(git diff --name-only "$GIT_PREVIOUS_SUCCESSFUL_COMMIT" "$GIT_COMMIT" || true)
              for SVC in $SERVICES; do
                echo "$DIFF_FILES" | grep -q "^backend/${SVC}/" && CHANGED="$CHANGED $SVC"
              done
            fi

            [ -z "$CHANGED" ] && CHANGED="$SERVICES"
            echo "$CHANGED" | xargs -n1 > .services_to_build
            echo "[plan] will build:"; cat .services_to_build
          '''
        }
      }
    }

    stage('Build & Push (parallel)') {
      steps {
        gitlabBuilds(builds: ['Build & Push']) {
          script {
            def tasks = [:]
            def accountId = sh(returnStdout: true, script: "cat .b_account_id").trim()
            def services   = readFile('.services_to_build').split("\\r?\\n").findAll { it?.trim() }
            def failed     = []

            services.each { svc ->
              tasks[svc] = {
                try {
                  sh '''#!/usr/bin/env bash
set -euo pipefail
TAG="''' + svc + '''-''' + env.BUILD_NUMBER + '''"
LATEST_TAG="''' + svc + '''-latest"
ACCOUNT_ID=$(cat .b_account_id)
URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${TAG}"
LATEST_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${LATEST_TAG}"

docker build -t ${ECR_REPO}:${TAG} ./backend/''' + svc + '''
docker tag ${ECR_REPO}:${TAG} ${URI}
docker tag ${ECR_REPO}:${TAG} ${LATEST_URI}
docker push ${URI}
docker push ${LATEST_URI}
echo "''' + svc + ''' ${URI}" > .img_''' + svc + '''
'''
                } catch (e) {
                  echo "[FAIL] ${svc}: ${e}"
                  failed << svc
                }
              }
            }

            parallel tasks

            sh 'rm -f .pushed_images || true; cat .img_* > .pushed_images || true'

            if (failed) {
              echo "[WARN] Failed services: ${failed.join(', ')}"
            }

            def pushed = sh(returnStdout:true, script: "test -s .pushed_images && wc -l < .pushed_images || echo 0").trim()
            if (pushed == "0") {
              error("No images pushed. Failing the build.")
            }
          }
        }
      }
    }

    stage('Kubeconfig') {
      steps {
        gitlabBuilds(builds: ['Kubeconfig']) {
          withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                            usernameVariable: 'AWS_ACCESS_KEY_ID',
                                            passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
            sh '''
              set -e
              export AWS_DEFAULT_REGION=${AWS_REGION}
              export AWS_EC2_METADATA_DISABLED=true
              aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER}
            '''
          }
        }
      }
    }

    stage('Apply K8s Manifests (always)') {
      steps {
        gitlabBuilds(builds: ['Apply Manifests']) {
          withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                            usernameVariable: 'AWS_ACCESS_KEY_ID',
                                            passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
            sh '''
              set -e
              export AWS_DEFAULT_REGION=${AWS_REGION}
              export AWS_EC2_METADATA_DISABLED=true
              kubectl apply -f backend/k8s/base/namespace.yaml
              kubectl -n ${NAMESPACE} apply -f backend/k8s/apps/
              kubectl -n ${NAMESPACE} apply -f backend/k8s/base/ingress-alb.yaml
            '''
          }
        }
      }
    }

    stage('Rolling Update') {
      steps {
        gitlabBuilds(builds: ['Rolling Update']) {
          withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                            usernameVariable: 'AWS_ACCESS_KEY_ID',
                                            passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
            sh '''
              set -e
              export AWS_DEFAULT_REGION=${AWS_REGION}
              export AWS_EC2_METADATA_DISABLED=true

              while read line; do
                SVC=$(echo $line | awk '{print $1}')
                IMG=$(echo $line | awk '{print $2}')
                BASE=${SVC%-service}
                DEPLOY="${BASE}-deploy"
                CONTAINER="${BASE}"
                if kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1; then
                  kubectl -n ${NAMESPACE} set image deploy/${DEPLOY} ${CONTAINER}=${IMG}
                else
                  echo "[skip] ${DEPLOY} not found"
                fi
              done < .pushed_images

              while read line; do
                SVC=$(echo $line | awk '{print $1}')
                BASE=${SVC%-service}
                DEPLOY="${BASE}-deploy"
                kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1 && \
                  kubectl -n ${NAMESPACE} rollout status deploy/${DEPLOY} || true
              done < .pushed_images
            '''
          }
        }
      }
    }
  }

  post {
    always {
      sh 'rm -f .b_account_id .services_to_build .pushed_images .img_* || true'
    }
    success {
      updateGitlabCommitStatus name: "${GITLAB_STAGE}", state: 'success'
    }
    failure {
      updateGitlabCommitStatus name: "${GITLAB_STAGE}", state: 'failed'
    }
  }
}
