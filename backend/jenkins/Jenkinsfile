pipeline {
  agent any
  options { timestamps() }

  environment {
    AWS_REGION = 'ap-northeast-2'
    CLUSTER    = 'o-o-cluster'
    ROLE_ARN   = 'arn:aws:iam::559543475782:role/JenkinsDeployerRole'
    ECR_REPO   = 'o-o-backend'
    NAMESPACE  = 'prod'
    PARALLEL_BUILD = 'true'    // 병렬 빌드 on/off
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('AssumeRole (to B)') {
      steps {
        sh '''
          set -e
          export AWS_DEFAULT_REGION=${AWS_REGION}
          CREDS=$(aws sts assume-role --role-arn ${ROLE_ARN} --role-session-name jenkins-deploy --no-cli-pager --output json)
          export AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r .Credentials.AccessKeyId)
          export AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r .Credentials.SecretAccessKey)
          export AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r .Credentials.SessionToken)
          aws sts get-caller-identity --no-cli-pager
        '''
      }
    }

    stage('ECR Login & Ensure Repo') {
      steps {
        sh '''
          set -e
          ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
          aws ecr describe-repositories --repository-names ${ECR_REPO} >/dev/null 2>&1 || \
            aws ecr create-repository --repository-name ${ECR_REPO} --image-scanning-configuration scanOnPush=true
          aws ecr get-login-password --region ${AWS_REGION} \
            | docker login --username AWS --password-stdin ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com
          echo $ACCOUNT_ID > .b_account_id
        '''
      }
    }

    stage('Detect Services to Build') {
      steps {
        sh '''
          set -e
          SERVICES=$(ls -d backend/*-service 2>/dev/null | xargs -n1 basename || true)
          if [ -z "$SERVICES" ]; then
            echo "No backend/*-service found"; exit 1
          fi

          CHANGED=""
          if git rev-parse --verify -q "$GIT_PREVIOUS_SUCCESSFUL_COMMIT" >/dev/null 2>&1; then
            DIFF_FILES=$(git diff --name-only "$GIT_PREVIOUS_SUCCESSFUL_COMMIT" "$GIT_COMMIT" || true)
            for SVC in $SERVICES; do
              if echo "$DIFF_FILES" | grep -q "^backend/${SVC}/"; then
                CHANGED="$CHANGED $SVC"
              fi
            done
          fi

          if [ -z "$CHANGED" ]; then
            CHANGED="$SERVICES"
          fi

          echo "$CHANGED" | xargs -n1 > .services_to_build
          echo "[plan] will build:"
          cat .services_to_build
        '''
      }
    }

    stage('Build & Push (parallel)') {
      steps {
        script {
          def tasks = [:]
          def accountId = sh(returnStdout: true, script: "cat .b_account_id").trim()
          def services = readFile('.services_to_build').split("\\r?\\n").findAll { it?.trim() }

          services.each { svc ->
            tasks[svc] = {
              sh """
                set -e
                TAG="${svc}-${BUILD_NUMBER}"
                URI="${accountId}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${TAG}"
                echo "==> Build ${svc}"
                docker build -t ${ECR_REPO}:${TAG} ./backend/${svc}
                echo "==> Push ${URI}"
                docker tag ${ECR_REPO}:${TAG} ${URI}
                docker push ${URI}
                echo "${svc} ${URI}" > .img_${svc}
              """
            }
          }

          if (env.PARALLEL_BUILD == 'true') {
            parallel tasks
          } else {
            tasks.each { name, body -> body() }
          }

          sh '''
            set -e
            rm -f .pushed_images || true
            cat .img_* > .pushed_images
            echo "[pushed]"
            cat .pushed_images
          '''
        }
      }
    }

    stage('Kubeconfig') {
      steps {
        sh 'aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER}'
      }
    }

    stage('Apply K8s Manifests (always)') {
      steps {
        sh '''
          set -e
          echo "[apply] base, apps, ingress..."
          kubectl apply -f backend/k8s/base/namespace.yaml
          kubectl -n ${NAMESPACE} apply -f backend/k8s/apps/
          kubectl -n ${NAMESPACE} apply -f backend/k8s/base/ingress-alb.yaml
        '''
      }
    }

    stage('Rolling Update') {
      steps {
        sh '''
          set -e
          while read line; do
            SVC=$(echo $line | awk '{print $1}')
            IMG=$(echo $line | awk '{print $2}')
            BASE=${SVC%-service}
            DEPLOY="${BASE}-deploy"
            CONTAINER="${BASE}"
            if kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1; then
              echo "==> rollout ${DEPLOY} (${CONTAINER}=${IMG})"
              kubectl -n ${NAMESPACE} set image deploy/${DEPLOY} ${CONTAINER}=${IMG}
            else
              echo "[skip] ${DEPLOY} not found"
            fi
          done < .pushed_images

          while read line; do
            SVC=$(echo $line | awk '{print $1}')
            BASE=${SVC%-service}
            DEPLOY="${BASE}-deploy"
            kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1 && \
              kubectl -n ${NAMESPACE} rollout status deploy/${DEPLOY} || true
          done < .pushed_images
        '''
      }
    }
  }

  post {
    always { sh 'rm -f .b_account_id .services_to_build .pushed_images .img_* || true' }
  }
}
