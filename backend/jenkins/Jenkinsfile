pipeline {
  agent any
  options { timestamps() }

  environment {
    AWS_REGION = 'ap-northeast-2'
    CLUSTER    = 'o-o-cluster'
    ECR_REPO   = 'o-o-backend'
    NAMESPACE  = 'prod'
    PARALLEL_BUILD = 'true'
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('ECR Login & Ensure Repo') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                          usernameVariable: 'AWS_ACCESS_KEY_ID',
                                          passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
          sh '''
            set -e
            export AWS_DEFAULT_REGION=${AWS_REGION}
            export AWS_EC2_METADATA_DISABLED=true

            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            # B계정이어야 함 (디버그)
            echo "[whoami] $ACCOUNT_ID"

            aws ecr describe-repositories --repository-names ${ECR_REPO} >/dev/null 2>&1 || \
              aws ecr create-repository --repository-name ${ECR_REPO} --image-scanning-configuration scanOnPush=true

            aws ecr get-login-password --region ${AWS_REGION} \
              | docker login --username AWS --password-stdin ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

            echo $ACCOUNT_ID > .b_account_id
          '''
        }
      }
    }

    stage('Detect Services to Build') {
      steps {
        sh '''
          set -e
          SERVICES=$(ls -d backend/*-service 2>/dev/null | xargs -n1 basename || true)
          [ -z "$SERVICES" ] && { echo "No backend/*-service found"; exit 1; }

          CHANGED=""
          if git rev-parse --verify -q "$GIT_PREVIOUS_SUCCESSFUL_COMMIT" >/dev/null 2>&1; then
            DIFF_FILES=$(git diff --name-only "$GIT_PREVIOUS_SUCCESSFUL_COMMIT" "$GIT_COMMIT" || true)
            for SVC in $SERVICES; do
              echo "$DIFF_FILES" | grep -q "^backend/${SVC}/" && CHANGED="$CHANGED $SVC"
            done
          fi

          [ -z "$CHANGED" ] && CHANGED="$SERVICES"
          echo "$CHANGED" | xargs -n1 > .services_to_build
          echo "[plan] will build:"; cat .services_to_build
        '''
      }
    }

    stage('Build & Push (parallel)') {
      steps {
        script {
          def tasks = [:]
          def accountId = sh(returnStdout: true, script: "cat .b_account_id").trim()
          def services   = readFile('.services_to_build').split("\\r?\\n").findAll { it?.trim() }
          def failed     = []

          services.each { svc ->
            tasks[svc] = {
              try {
                sh '''#!/usr/bin/env bash
    set -euo pipefail
    TAG="''' + svc + '''-''' + env.BUILD_NUMBER + '''"
    ACCOUNT_ID=$(cat .b_account_id)
    URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${TAG}"

    echo "==> Build ''' + svc + ''' as ${URI}"
    docker build -t ${ECR_REPO}:${TAG} ./backend/''' + svc + '''
    docker tag ${ECR_REPO}:${TAG} ${URI}
    docker push ${URI}
    echo "''' + svc + ''' ${URI}" > .img_''' + svc + '''
    '''
              } catch (e) {
                echo "[FAIL] ${svc}: ${e}"
                failed << svc
              }
            }
          }

          parallel tasks

          sh 'rm -f .pushed_images || true; cat .img_* > .pushed_images || true'

          // 실패 리스트 프린트
          if (failed) {
            echo "[WARN] Failed services: ${failed.join(', ')}"
          }

          // 아무것도 못 밀었으면 전체 실패 처리
          def pushed = sh(returnStdout:true, script: "test -s .pushed_images && wc -l < .pushed_images || echo 0").trim()
          if (pushed == "0") {
            error("No images pushed. Failing the build.")
          }
        }
      }
    }


    stage('Kubeconfig') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                          usernameVariable: 'AWS_ACCESS_KEY_ID',
                                          passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
          sh '''
            set -e
            export AWS_DEFAULT_REGION=${AWS_REGION}
            export AWS_EC2_METADATA_DISABLED=true
            aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER}
          '''
        }
      }
    }

    stage('Apply K8s Manifests (always)') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                          usernameVariable: 'AWS_ACCESS_KEY_ID',
                                          passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
          sh '''
            set -e
            export AWS_DEFAULT_REGION=${AWS_REGION}
            export AWS_EC2_METADATA_DISABLED=true
            kubectl apply -f backend/k8s/base/namespace.yaml
            kubectl -n ${NAMESPACE} apply -f backend/k8s/apps/
            kubectl -n ${NAMESPACE} apply -f backend/k8s/base/ingress-alb.yaml
          '''
        }
      }
    }

    stage('Rolling Update') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                          usernameVariable: 'AWS_ACCESS_KEY_ID',
                                          passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
          sh '''
            set -e
            export AWS_DEFAULT_REGION=${AWS_REGION}
            export AWS_EC2_METADATA_DISABLED=true

            while read line; do
              SVC=$(echo $line | awk '{print $1}')
              IMG=$(echo $line | awk '{print $2}')
              BASE=${SVC%-service}
              DEPLOY="${BASE}-deploy"
              CONTAINER="${BASE}"
              if kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1; then
                kubectl -n ${NAMESPACE} set image deploy/${DEPLOY} ${CONTAINER}=${IMG}
              else
                echo "[skip] ${DEPLOY} not found"
              fi
            done < .pushed_images

            while read line; do
              SVC=$(echo $line | awk '{print $1}')
              BASE=${SVC%-service}
              DEPLOY="${BASE}-deploy"
              kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1 && \
                kubectl -n ${NAMESPACE} rollout status deploy/${DEPLOY} || true
            done < .pushed_images
          '''
        }
      }
    }

  post {
    always { sh 'rm -f .b_account_id .services_to_build .pushed_images .img_* || true' }
  }
}
