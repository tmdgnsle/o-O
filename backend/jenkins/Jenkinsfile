pipeline {
  agent any
  options { timestamps() }

  environment {
    AWS_REGION = 'ap-northeast-2'
    CLUSTER    = 'o-o-cluster'
    ECR_REPO   = 'o-o-backend'
    NAMESPACE  = 'prod'
    PARALLEL_BUILD = 'true'
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('ECR Login & Ensure Repo') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                          usernameVariable: 'AWS_ACCESS_KEY_ID',
                                          passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
          sh '''
            set -e
            export AWS_DEFAULT_REGION=${AWS_REGION}
            export AWS_EC2_METADATA_DISABLED=true

            ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
            # B계정이어야 함 (디버그)
            echo "[whoami] $ACCOUNT_ID"

            aws ecr describe-repositories --repository-names ${ECR_REPO} >/dev/null 2>&1 || \
              aws ecr create-repository --repository-name ${ECR_REPO} --image-scanning-configuration scanOnPush=true

            aws ecr get-login-password --region ${AWS_REGION} \
              | docker login --username AWS --password-stdin ${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com

            echo $ACCOUNT_ID > .b_account_id
          '''
        }
      }
    }

    stage('Detect Services to Build') {
      steps {
        sh '''
          set -e
          SERVICES=$(ls -d backend/*-service 2>/dev/null | xargs -n1 basename || true)
          [ -z "$SERVICES" ] && { echo "No backend/*-service found"; exit 1; }

          CHANGED=""
          if git rev-parse --verify -q "$GIT_PREVIOUS_SUCCESSFUL_COMMIT" >/dev/null 2>&1; then
            DIFF_FILES=$(git diff --name-only "$GIT_PREVIOUS_SUCCESSFUL_COMMIT" "$GIT_COMMIT" || true)
            for SVC in $SERVICES; do
              echo "$DIFF_FILES" | grep -q "^backend/${SVC}/" && CHANGED="$CHANGED $SVC"
            done
          fi

          [ -z "$CHANGED" ] && CHANGED="$SERVICES"
          echo "$CHANGED" | xargs -n1 > .services_to_build
          echo "[plan] will build:"; cat .services_to_build
        '''
      }
    }

    stage('Build & Push (parallel)') {
      steps {
        script {
          def tasks = [:]
          def accountId = sh(returnStdout: true, script: "cat .b_account_id").trim()
          def services = readFile('.services_to_build').split("\\r?\\n").findAll { it?.trim() }

          services.each { svc ->
            tasks[svc] = {
              sh """
                set -e
                TAG="${svc}-${BUILD_NUMBER}"
                URI="${accountId}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPO}:${TAG}"
                docker build -t ${ECR_REPO}:${TAG} ./backend/${svc}
                docker tag ${ECR_REPO}:${TAG} ${URI}
                docker push ${URI}
                echo "${svc} ${URI}" > .img_${svc}
              """
            }
          }
          parallel tasks
          sh 'rm -f .pushed_images || true; cat .img_* > .pushed_images; cat .pushed_images'
        }
      }
    }

    stage('Kubeconfig') {
      steps {
        withCredentials([usernamePassword(credentialsId: 'aws-creds-b',
                                          usernameVariable: 'AWS_ACCESS_KEY_ID',
                                          passwordVariable: 'AWS_SECRET_ACCESS_KEY')]) {
          sh '''
            set -e
            export AWS_DEFAULT_REGION=${AWS_REGION}
            export AWS_EC2_METADATA_DISABLED=true
            aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER}
          '''
        }
      }
    }

    stage('Apply K8s Manifests (always)') {
      steps {
        sh '''
          set -e
          kubectl apply -f backend/k8s/base/namespace.yaml
          kubectl -n ${NAMESPACE} apply -f backend/k8s/apps/
          kubectl -n ${NAMESPACE} apply -f backend/k8s/base/ingress-alb.yaml
        '''
      }
    }

    stage('Rolling Update') {
      steps {
        sh '''
          set -e
          while read line; do
            SVC=$(echo $line | awk '{print $1}')
            IMG=$(echo $line | awk '{print $2}')
            BASE=${SVC%-service}
            DEPLOY="${BASE}-deploy"
            CONTAINER="${BASE}"
            if kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1; then
              kubectl -n ${NAMESPACE} set image deploy/${DEPLOY} ${CONTAINER}=${IMG}
            else
              echo "[skip] ${DEPLOY} not found"
            fi
          done < .pushed_images

          while read line; do
            SVC=$(echo $line | awk '{print $1}')
            BASE=${SVC%-service}
            DEPLOY="${BASE}-deploy"
            kubectl -n ${NAMESPACE} get deploy/${DEPLOY} >/dev/null 2>&1 && \
              kubectl -n ${NAMESPACE} rollout status deploy/${DEPLOY} || true
          done < .pushed_images
        '''
      }
    }
  }

  post {
    always { sh 'rm -f .b_account_id .services_to_build .pushed_images .img_* || true' }
  }
}
