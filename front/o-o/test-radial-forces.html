<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Radial Layout with Forces - Edge Crossing Test</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #f9fafb;
    }
    #container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      color: #1f2937;
      margin-bottom: 10px;
    }
    .info {
      background: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .info h3 {
      margin: 0 0 10px 0;
      color: #374151;
    }
    .info ul {
      margin: 5px 0;
      padding-left: 20px;
      color: #6b7280;
    }
    svg {
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .edge {
      stroke: #3b82f6;
      stroke-width: 2;
      fill: none;
    }
    .node {
      cursor: pointer;
    }
    .node circle {
      fill: #8b5cf6;
      stroke: white;
      stroke-width: 3;
    }
    .node:hover circle {
      fill: #7c3aed;
    }
    .node text {
      fill: white;
      font-size: 14px;
      font-weight: 600;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
    }
    .stats {
      margin-top: 20px;
      padding: 15px;
      background: white;
      border-radius: 8px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }
    .stats div {
      margin: 5px 0;
      color: #374151;
    }
    .stats .success {
      color: #10b981;
      font-weight: 600;
    }
    .stats .error {
      color: #ef4444;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div id="container">
    <h1>ğŸŒ³ Radial Layout with Force Simulation</h1>

    <div class="info">
      <h3>âœ… ë ˆì´ì•„ì›ƒ ì¡°ê±´</h3>
      <ul>
        <li><strong>ëª¨ë“  edgeëŠ” 100% ì§ì„ </strong> (ê³¡ì„  ê¸ˆì§€)</li>
        <li><strong>Edge ê°„ êµì°¨(crossing) ë°©ì§€</strong></li>
        <li><strong>ë…¸ë“œ ê°„ ì¶©ëŒ ë°©ì§€</strong> (forceManyBody + forceCollide)</li>
        <li><strong>ë°©ì‚¬í˜• íŠ¸ë¦¬ êµ¬ì¡° ìœ ì§€</strong> (depthë³„ radius)</li>
        <li><strong>Force simulation ì ìš©</strong></li>
      </ul>
    </div>

    <svg width="1200" height="800"></svg>

    <div class="stats" id="stats"></div>
  </div>

  <script>
    // ===== í…ŒìŠ¤íŠ¸ ë°ì´í„° =====
    const testNodes = [
      { id: '1', parentId: null, keyword: 'Root' },
      { id: '2', parentId: '1', keyword: 'Child 1' },
      { id: '3', parentId: '1', keyword: 'Child 2' },
      { id: '4', parentId: '1', keyword: 'Child 3' },
      { id: '5', parentId: '2', keyword: 'GC 1-1' },
      { id: '6', parentId: '2', keyword: 'GC 1-2' },
      { id: '7', parentId: '3', keyword: 'GC 2-1' },
      { id: '8', parentId: '3', keyword: 'GC 2-2' },
      { id: '9', parentId: '3', keyword: 'GC 2-3' },
      { id: '10', parentId: '4', keyword: 'GC 3-1' },
      { id: '11', parentId: '5', keyword: 'GGC 1' },
      { id: '12', parentId: '5', keyword: 'GGC 2' },
    ];

    const centerX = 600;
    const centerY = 400;
    const baseRadius = 200;
    const nodeRadius = 40;

    // ===== Edge Crossing ê²€ì‚¬ í•¨ìˆ˜ =====
    function doSegmentsIntersect(p1, p2, p3, p4) {
      const ccw = (A, B, C) => (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
      return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
    }

    function countEdgeCrossings(positions, edges) {
      let crossings = 0;
      for (let i = 0; i < edges.length; i++) {
        for (let j = i + 1; j < edges.length; j++) {
          const e1 = edges[i];
          const e2 = edges[j];

          if (e1.source === e2.source || e1.source === e2.target ||
              e1.target === e2.source || e1.target === e2.target) {
            continue;
          }

          const p1 = positions.get(e1.source);
          const p2 = positions.get(e1.target);
          const p3 = positions.get(e2.source);
          const p4 = positions.get(e2.target);

          if (p1 && p2 && p3 && p4 && doSegmentsIntersect(p1, p2, p3, p4)) {
            crossings++;
          }
        }
      }
      return crossings;
    }

    // ===== ë ˆì´ì•„ì›ƒ ê³„ì‚° =====
    async function calculateLayout() {
      console.log('[Test] Starting layout calculation...');

      // 1. ê³„ì¸µ êµ¬ì¡° ìƒì„±
      const nodeMap = new Map();
      let rootId = null;

      testNodes.forEach(node => {
        nodeMap.set(node.id, { id: node.id, keyword: node.keyword, children: [] });
        if (!node.parentId) rootId = node.id;
      });

      testNodes.forEach(node => {
        if (node.parentId) {
          const parent = nodeMap.get(node.parentId);
          const child = nodeMap.get(node.id);
          if (parent && child) parent.children.push(child);
        }
      });

      const root = nodeMap.get(rootId);
      const hierarchy = d3.hierarchy(root, d => d.children);

      // 2. Tree layout
      const treeLayout = d3.tree()
        .nodeSize([nodeRadius * 6.5, baseRadius])
        .separation((a, b) => a.parent === b.parent ? 2.0 : 3.5);

      const treeRoot = treeLayout(hierarchy);

      // 3. ê·¹ì¢Œí‘œ ë³€í™˜
      let minX = Infinity, maxX = -Infinity;
      treeRoot.each(node => {
        if (node.x < minX) minX = node.x;
        if (node.x > maxX) maxX = node.x;
      });

      const xRange = maxX - minX || 1;
      const simNodes = [];

      treeRoot.each(node => {
        const normalizedX = (node.x - minX) / xRange;
        const angle = normalizedX * 2 * Math.PI;
        const radius = node.depth * baseRadius;

        const x = centerX + radius * Math.sin(angle);
        const y = centerY - radius * Math.cos(angle);

        simNodes.push({
          id: node.data.id,
          keyword: node.data.keyword,
          x,
          y,
          fx: node.depth === 0 ? centerX : null,
          fy: node.depth === 0 ? centerY : null,
          depth: node.depth,
          angle,
          radius,
        });
      });

      // Edge ì •ë³´
      const edges = testNodes
        .filter(n => n.parentId)
        .map(n => ({ source: n.parentId, target: n.id }));

      // 4. Force simulation
      return new Promise(resolve => {
        const simulation = d3.forceSimulation(simNodes)
          .force('charge', d3.forceManyBody().strength(-1200).distanceMax(baseRadius * 4))
          .force('collide', d3.forceCollide().radius(nodeRadius * 3.5).strength(1.0).iterations(5))
          .force('radial', d3.forceRadial(d => d.radius, centerX, centerY).strength(0.7))
          .alphaDecay(0.012)
          .velocityDecay(0.3);

        let tickCount = 0;
        const maxTicks = 400;

        simulation.on('tick', () => {
          tickCount++;
          if (tickCount % 100 === 0) {
            const posMap = new Map(simNodes.map(n => [n.id, { x: n.x, y: n.y }]));
            const crossings = countEdgeCrossings(posMap, edges);
            console.log(`[Test] Tick ${tickCount}: ${crossings} edge crossings`);
          }
        });

        simulation.on('end', () => {
          const posMap = new Map(simNodes.map(n => [n.id, { x: n.x, y: n.y }]));
          const finalCrossings = countEdgeCrossings(posMap, edges);

          console.log(`[Test] Simulation complete: ${finalCrossings} crossings`);

          // ë¬´ì¡°ê±´ depthë³„ ê· ë“± ê°ë„ ì¬ë°°ì¹˜ (ê²¹ì¹¨ ì™„ì „ ë°©ì§€)
          console.log('[Test] Applying uniform angle distribution...');
          const depthGroups = new Map();
          simNodes.forEach(node => {
            if (!depthGroups.has(node.depth)) depthGroups.set(node.depth, []);
            depthGroups.get(node.depth).push(node);
          });

          depthGroups.forEach((nodes, depth) => {
            if (depth === 0) return;

            // í˜„ì¬ ê°ë„ ê³„ì‚° í›„ ì •ë ¬
            nodes.forEach(node => {
              const dx = node.x - centerX;
              const dy = node.y - centerY;
              node.angle = Math.atan2(dx, -dy);
              if (node.angle < 0) node.angle += 2 * Math.PI;
            });

            nodes.sort((a, b) => a.angle - b.angle);

            // ìµœì†Œ ë°˜ì§€ë¦„ ê³„ì‚° (ê²¹ì¹¨ ë°©ì§€)
            const nodeCount = nodes.length;
            const nodeSpacing = nodeRadius * 4;
            const minCircumference = nodeCount * nodeSpacing;
            const minRadius = minCircumference / (2 * Math.PI);

            const baseRadiusForDepth = depth * baseRadius;
            const actualRadius = Math.max(baseRadiusForDepth, minRadius);

            if (actualRadius > baseRadiusForDepth) {
              console.log(`[Test] ğŸ”§ Depth ${depth}: radius adjusted ${baseRadiusForDepth.toFixed(0)} â†’ ${actualRadius.toFixed(0)}`);
            }

            // ê· ë“± ì¬ë°°ì¹˜
            const angleStep = (2 * Math.PI) / nodeCount;
            const startAngle = nodes[0].angle;

            nodes.forEach((node, i) => {
              const newAngle = startAngle + (i * angleStep);
              node.x = centerX + actualRadius * Math.sin(newAngle);
              node.y = centerY - actualRadius * Math.cos(newAngle);
            });

            console.log(`[Test] Depth ${depth}: ${nodeCount} nodes, radius: ${actualRadius.toFixed(0)}, ${(angleStep * 180 / Math.PI).toFixed(1)}Â° apart`);
          });

          const adjustedPosMap = new Map(simNodes.map(n => [n.id, { x: n.x, y: n.y }]));
          const adjustedCrossings = countEdgeCrossings(adjustedPosMap, edges);
          console.log(`[Test] After uniform distribution: ${adjustedCrossings} crossings`);

          resolve({ nodes: simNodes, edges });
        });

        setTimeout(() => simulation.stop(), 10000);
      });
    }

    // ===== ë Œë”ë§ =====
    async function render() {
      const startTime = performance.now();
      const { nodes, edges } = await calculateLayout();
      const endTime = performance.now();

      const svg = d3.select('svg');
      const g = svg.append('g');

      // Edge ê·¸ë¦¬ê¸° (100% ì§ì„ )
      g.selectAll('.edge')
        .data(edges)
        .enter()
        .append('path')
        .attr('class', 'edge')
        .attr('d', d => {
          const source = nodes.find(n => n.id === d.source);
          const target = nodes.find(n => n.id === d.target);
          if (!source || !target) return '';
          // ğŸ”¥ ì§ì„ ë§Œ ì‚¬ìš© (M = Move, L = Line)
          return `M ${source.x} ${source.y} L ${target.x} ${target.y}`;
        });

      // Node ê·¸ë¦¬ê¸°
      const nodeGroups = g.selectAll('.node')
        .data(nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .attr('transform', d => `translate(${d.x}, ${d.y})`);

      nodeGroups.append('circle')
        .attr('r', nodeRadius);

      nodeGroups.append('text')
        .text(d => d.keyword);

      // í†µê³„ í‘œì‹œ
      const posMap = new Map(nodes.map(n => [n.id, { x: n.x, y: n.y }]));
      const finalCrossings = countEdgeCrossings(posMap, edges);

      const statsDiv = document.getElementById('stats');
      statsDiv.innerHTML = `
        <div><strong>ì´ ë…¸ë“œ:</strong> ${nodes.length}ê°œ</div>
        <div><strong>ì´ ì—£ì§€:</strong> ${edges.length}ê°œ</div>
        <div><strong>ê³„ì‚° ì‹œê°„:</strong> ${(endTime - startTime).toFixed(1)}ms</div>
        <div class="${finalCrossings === 0 ? 'success' : 'error'}">
          <strong>Edge êµì°¨:</strong> ${finalCrossings}ê°œ ${finalCrossings === 0 ? 'âœ…' : 'âŒ'}
        </div>
        <div><strong>Edge íƒ€ì…:</strong> 100% ì§ì„  âœ…</div>
        <div><strong>Force Simulation:</strong> ì ìš©ë¨ âœ…</div>
      `;

      console.log('[Test] Rendering complete');
    }

    // ì‹¤í–‰
    render();
  </script>
</body>
</html>
