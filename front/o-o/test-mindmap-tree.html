<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ë§ˆì¸ë“œë§µ íŠ¸ë¦¬ ì‹œê°í™” í…ŒìŠ¤íŠ¸</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      background: #f5f5f5;
    }

    #container {
      width: 100%;
      height: 800px;
      background: white;
      border: 2px solid #333;
      border-radius: 8px;
      overflow: hidden;
      position: relative;
    }

    svg {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    svg:active {
      cursor: grabbing;
    }

    .edge {
      stroke: #3b82f6;
      stroke-width: 3;
      fill: none;
      opacity: 0.8;
    }

    .node-group {
      cursor: pointer;
    }

    .node-circle {
      filter: drop-shadow(0 4px 6px rgba(0, 0, 0, 0.1));
    }

    .node-text {
      font-size: 14px;
      font-weight: 600;
      fill: white;
      text-anchor: middle;
      dominant-baseline: middle;
      pointer-events: none;
      user-select: none;
    }

    .info-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      max-width: 300px;
      font-size: 13px;
    }

    .info-panel h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #333;
    }

    .info-panel ul {
      margin: 0;
      padding-left: 20px;
    }

    .info-panel li {
      margin: 5px 0;
      color: #666;
    }

    .stats {
      margin-top: 15px;
      padding-top: 15px;
      border-top: 1px solid #eee;
    }

    .stats div {
      margin: 5px 0;
    }

    .stats strong {
      color: #3b82f6;
    }
  </style>
</head>
<body>
  <h1 style="margin: 0 0 20px 0; color: #333;">ë§ˆì¸ë“œë§µ íŠ¸ë¦¬ êµ¬ì¡° ì‹œê°í™”</h1>

  <div id="container">
    <svg id="mindmap"></svg>

    <div class="info-panel">
      <h3>ğŸ¯ ì‹œê°í™” ì •ë³´</h3>
      <ul>
        <li>ëª¨ë“  ë¶€ëª¨-ìì‹ ê´€ê³„ê°€ <strong>ì„ ìœ¼ë¡œ ì—°ê²°</strong>ë˜ì–´ ìˆìŠµë‹ˆë‹¤</li>
        <li>ë“œë˜ê·¸í•˜ì—¬ í™”ë©´ì„ ì´ë™í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</li>
        <li>ë§ˆìš°ìŠ¤ íœ ë¡œ í™•ëŒ€/ì¶•ì†Œ ê°€ëŠ¥í•©ë‹ˆë‹¤</li>
        <li>ë…¸ë“œë¥¼ í´ë¦­í•˜ë©´ ì •ë³´ê°€ í‘œì‹œë©ë‹ˆë‹¤</li>
      </ul>

      <div class="stats">
        <div><strong>ì´ ë…¸ë“œ:</strong> <span id="node-count">0</span>ê°œ</div>
        <div><strong>ì´ ì—°ê²°ì„ :</strong> <span id="edge-count">0</span>ê°œ</div>
        <div><strong>íŠ¸ë¦¬ ê¹Šì´:</strong> <span id="tree-depth">0</span> ë ˆë²¨</div>
      </div>
    </div>
  </div>

  <script>
    // ============================================
    // ë°ì´í„° ì •ì˜
    // ============================================

    // íŠ¸ë¦¬ êµ¬ì¡° ë°ì´í„°
    const treeData = {
      keyword: "Root",
      children: [
        {
          keyword: "ëª¨ë¸ íŒŒì¸íŠœë‹",
          children: [
            { keyword: "ì„ë² ë”©" },
            { keyword: "ë ˆí¼ëŸ°ìŠ¤ ìœˆë„ìš°" }
          ]
        },
        {
          keyword: "í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§",
          children: [
            { keyword: "ë°ì´í„° ë¶„ì„" },
            { keyword: "ë¡œê·¸ ìˆ˜ì§‘" },
            { keyword: "ì‹œê°í™”" }
          ]
        },
        {
          keyword: "AI ëª¨ë¸",
          children: [
            { keyword: "ì‹¤ì‹œê°„ í˜‘ì—…" }
          ]
        },
        {
          keyword: "ì‚¬ìš©ì ê²½í—˜ ê°œì„ ",
          children: [
            { keyword: "UI/UX" },
            { keyword: "ë°˜ì‘í˜• ë””ìì¸" }
          ]
        },
        {
          keyword: "ì‹œìŠ¤í…œ",
          children: [
            { keyword: "ì»¤ì„œ ë™ê¸°í™”" },
            { keyword: "ì¶©ëŒ í•´ê²°" },
            { keyword: "ë²„ì „ ê´€ë¦¬" }
          ]
        }
      ]
    };

    // ============================================
    // íŠ¸ë¦¬ ë°ì´í„°ë¥¼ ë…¸ë“œ/ì—£ì§€ë¡œ ë³€í™˜
    // ============================================

    function flattenTree(tree, parentId = null) {
      const nodes = [];
      const edges = [];
      let idCounter = 0;

      function traverse(node, parent) {
        const currentId = `node-${idCounter++}`;

        nodes.push({
          id: currentId,
          keyword: node.keyword,
          parentId: parent
        });

        if (parent !== null) {
          edges.push({
            id: `${parent}-${currentId}`,
            source: parent,
            target: currentId
          });
        }

        if (node.children) {
          node.children.forEach(child => traverse(child, currentId));
        }
      }

      traverse(tree, parentId);
      return { nodes, edges };
    }

    const { nodes, edges } = flattenTree(treeData);

    console.log('ğŸ“Š ìƒì„±ëœ ë°ì´í„°:', { nodes, edges });

    // ============================================
    // ë…¸ë“œ ë ˆë²¨ ê³„ì‚°
    // ============================================

    function calculateNodeLevels(nodes) {
      const levels = new Map();

      // ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°
      nodes.forEach(node => {
        if (node.parentId === null) {
          levels.set(node.id, 0);
        }
      });

      // BFSë¡œ ìì‹ ë ˆë²¨ ê³„ì‚°
      let changed = true;
      let maxIterations = 100;
      let iteration = 0;

      while (changed && iteration < maxIterations) {
        changed = false;
        iteration++;

        nodes.forEach(node => {
          if (!levels.has(node.id) && node.parentId) {
            const parentLevel = levels.get(node.parentId);
            if (parentLevel !== undefined) {
              levels.set(node.id, parentLevel + 1);
              changed = true;
            }
          }
        });
      }

      return levels;
    }

    // ============================================
    // ë°©ì‚¬í˜• ë ˆì´ì•„ì›ƒ ê³„ì‚°
    // ============================================

    function calculateRadialLayout(nodes, centerX, centerY) {
      const levels = calculateNodeLevels(nodes);
      const nodesByDepth = new Map();

      // depthë³„ë¡œ ë…¸ë“œ ê·¸ë£¹í™”
      nodes.forEach(node => {
        const depth = levels.get(node.id) ?? 0;
        if (!nodesByDepth.has(depth)) {
          nodesByDepth.set(depth, []);
        }
        nodesByDepth.get(depth).push(node);
      });

      const positions = new Map();

      // depthë³„ë¡œ ì²˜ë¦¬
      nodesByDepth.forEach((depthNodes, depth) => {
        if (depth === 0) {
          // ë£¨íŠ¸ ë…¸ë“œëŠ” ì¤‘ì‹¬ì—
          depthNodes.forEach(node => {
            positions.set(node.id, { x: centerX, y: centerY });
          });
        } else {
          // depthì— ë”°ë¥¸ ë°˜ì§€ë¦„
          const radius = 150 + (depth - 1) * 150;
          const count = depthNodes.length;

          depthNodes.forEach((node, i) => {
            const theta = (2 * Math.PI / count) * i;
            const x = centerX + radius * Math.cos(theta);
            const y = centerY + radius * Math.sin(theta);
            positions.set(node.id, { x, y });
          });
        }
      });

      return { positions, levels };
    }

    // ============================================
    // ë² ì§€ì–´ ê³¡ì„  ê²½ë¡œ ìƒì„±
    // ============================================

    function createBezierPath(source, target) {
      const dx = target.x - source.x;
      const dy = target.y - source.y;

      const controlPointOffset = 40;
      const midX = (source.x + target.x) / 2;
      const midY = (source.y + target.y) / 2;

      const angle = Math.atan2(dy, dx);
      const perpAngle = angle + Math.PI / 2;

      const controlX = midX + Math.cos(perpAngle) * controlPointOffset;
      const controlY = midY + Math.sin(perpAngle) * controlPointOffset;

      return `M ${source.x} ${source.y} Q ${controlX} ${controlY} ${target.x} ${target.y}`;
    }

    // ============================================
    // D3 ì‹œê°í™”
    // ============================================

    const svg = d3.select("#mindmap");
    const container = document.getElementById("container");
    const width = container.clientWidth;
    const height = container.clientHeight;
    const centerX = width / 2;
    const centerY = height / 2;

    // ë ˆì´ì•„ì›ƒ ê³„ì‚°
    const { positions, levels } = calculateRadialLayout(nodes, centerX, centerY);

    // ìœ„ì¹˜ ì •ë³´ë¥¼ ë…¸ë“œì— ì¶”ê°€
    nodes.forEach(node => {
      const pos = positions.get(node.id);
      node.x = pos.x;
      node.y = pos.y;
      node.level = levels.get(node.id);
    });

    console.log('ğŸ“ ë…¸ë“œ ìœ„ì¹˜:', nodes);

    // ì¤Œ/íŒ¬ ì„¤ì •
    const g = svg.append("g");

    const zoom = d3.zoom()
      .scaleExtent([0.3, 3])
      .on("zoom", (event) => {
        g.attr("transform", event.transform);
      });

    svg.call(zoom);

    // ============================================
    // ì—£ì§€(ì—°ê²°ì„ ) ë Œë”ë§ - ë¨¼ì € ê·¸ë ¤ì„œ ë’¤ì— ë°°ì¹˜
    // ============================================

    const edgesGroup = g.append("g").attr("class", "edges");

    const edgePaths = edgesGroup
      .selectAll("path")
      .data(edges)
      .enter()
      .append("path")
      .attr("class", "edge")
      .attr("d", d => {
        const source = nodes.find(n => n.id === d.source);
        const target = nodes.find(n => n.id === d.target);

        console.log(`ğŸ”— ì—£ì§€ ${d.id}:`, {
          source: { id: source.id, x: source.x, y: source.y },
          target: { id: target.id, x: target.x, y: target.y }
        });

        return createBezierPath(
          { x: source.x, y: source.y },
          { x: target.x, y: target.y }
        );
      });

    console.log(`âœ… ì´ ${edges.length}ê°œì˜ ì—°ê²°ì„ ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!`);

    // ============================================
    // ë…¸ë“œ ë Œë”ë§ - ì—£ì§€ ìœ„ì— ë°°ì¹˜
    // ============================================

    const nodesGroup = g.append("g").attr("class", "nodes");

    const nodeGroups = nodesGroup
      .selectAll("g")
      .data(nodes)
      .enter()
      .append("g")
      .attr("class", "node-group")
      .attr("transform", d => `translate(${d.x}, ${d.y})`);

    // ë…¸ë“œ ì›
    nodeGroups
      .append("circle")
      .attr("class", "node-circle")
      .attr("r", 50)
      .attr("fill", d => {
        // ë ˆë²¨ë³„ë¡œ ìƒ‰ìƒ êµ¬ë¶„
        const colors = ["#ef4444", "#f59e0b", "#10b981", "#3b82f6", "#8b5cf6", "#ec4899"];
        return colors[d.level % colors.length];
      })
      .on("click", function(event, d) {
        event.stopPropagation();
        alert(`ë…¸ë“œ: ${d.keyword}\në ˆë²¨: ${d.level}\nìœ„ì¹˜: (${d.x.toFixed(0)}, ${d.y.toFixed(0)})`);
      });

    // ë…¸ë“œ í…ìŠ¤íŠ¸
    nodeGroups
      .append("text")
      .attr("class", "node-text")
      .text(d => d.keyword)
      .each(function(d) {
        // ê¸´ í…ìŠ¤íŠ¸ëŠ” ì¤„ë°”ê¿ˆ
        const text = d3.select(this);
        const words = d.keyword.split(' ');

        if (words.length > 1) {
          text.text('');
          words.forEach((word, i) => {
            text.append("tspan")
              .attr("x", 0)
              .attr("dy", i === 0 ? 0 : "1.2em")
              .text(word);
          });
        }
      });

    // ============================================
    // í†µê³„ ì—…ë°ì´íŠ¸
    // ============================================

    const maxLevel = Math.max(...Array.from(levels.values()));

    document.getElementById("node-count").textContent = nodes.length;
    document.getElementById("edge-count").textContent = edges.length;
    document.getElementById("tree-depth").textContent = maxLevel + 1;

    // ============================================
    // ê²€ì¦ ë¡œê·¸
    // ============================================

    console.log('='.repeat(50));
    console.log('âœ… ë§ˆì¸ë“œë§µ ì‹œê°í™” ì™„ë£Œ!');
    console.log('='.repeat(50));
    console.log(`ğŸ“Š ì´ ë…¸ë“œ: ${nodes.length}ê°œ`);
    console.log(`ğŸ”— ì´ ì—°ê²°ì„ : ${edges.length}ê°œ`);
    console.log(`ğŸ“ íŠ¸ë¦¬ ê¹Šì´: ${maxLevel + 1} ë ˆë²¨`);
    console.log('='.repeat(50));
    console.log('');
    console.log('ğŸ¯ ë¶€ëª¨-ìì‹ ì—°ê²° ê´€ê³„:');
    edges.forEach(edge => {
      const source = nodes.find(n => n.id === edge.source);
      const target = nodes.find(n => n.id === edge.target);
      console.log(`  ${source.keyword} â†’ ${target.keyword}`);
    });
    console.log('='.repeat(50));

    // ëª¨ë“  ì—£ì§€ê°€ ì‹¤ì œë¡œ ë Œë”ë§ë˜ì—ˆëŠ”ì§€ í™•ì¸
    const renderedEdgeCount = document.querySelectorAll('.edge').length;
    if (renderedEdgeCount === edges.length) {
      console.log(`âœ… ëª¨ë“  ì—°ê²°ì„ ì´ í™”ë©´ì— ë Œë”ë§ë˜ì—ˆìŠµë‹ˆë‹¤! (${renderedEdgeCount}ê°œ)`);
    } else {
      console.error(`âŒ ì—°ê²°ì„  ë Œë”ë§ ì˜¤ë¥˜: ì˜ˆìƒ ${edges.length}ê°œ, ì‹¤ì œ ${renderedEdgeCount}ê°œ`);
    }
  </script>
</body>
</html>